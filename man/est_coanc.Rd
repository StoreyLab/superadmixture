% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/est_coanc.R
\name{est_coanc}
\alias{est_coanc}
\title{Estimate the coancestry among antecedent populations}
\usage{
est_coanc(
  coanc_indiv,
  admix_proportions,
  tol = 1e-08,
  max_iters = 10000,
  init_method = "LS",
  model = "super",
  verbose = FALSE
)
}
\arguments{
\item{coanc_indiv}{An \eqn{n \times n} matrix representing coancestry among individuals.}

\item{admix_proportions}{A \eqn{K} \eqn{\times} \eqn{n} matrix representing admixture proportions.}

\item{tol}{A scalar for convergence criterion. If the relative change of
\eqn{\|\boldsymbol{\Theta} - \boldsymbol{Q}' \boldsymbol{\Lambda} \boldsymbol{Q}\|_F} is less than \code{tol},
the algorithm halts.}

\item{max_iters}{Maximum number of iterations.}

\item{init_method}{One of "random" or "LS" (default). If \code{init_method} is "random",
the initial \eqn{\boldsymbol{\Lambda}} is set to be a diagonal matrix whose diagonal elements
are sampled from the Uniform(0,1) distribution. Otherwise, the initial \eqn{\boldsymbol{\Lambda}} is set to be
\eqn{(\boldsymbol{Q}\boldsymbol{Q}^{\prime})^{-1} \boldsymbol{\Theta} (\boldsymbol{Q}\boldsymbol{Q}^{\prime})^{-1}}.}

\item{model}{One of "standard" or "super" (default). If \code{model} is "standard", the
standard admixture model is fitted. If \code{model} is "super", the the super-admixture model is fitted.}

\item{verbose}{A Boolean that controls the returned values. If \code{verbose} is FALSE (default), only the estimated \eqn{\boldsymbol{\Lambda}}
is returned. If TRUE, \code{est_coanc} returns a list consisting of the estimated \eqn{\boldsymbol{\Lambda}},
a list of \eqn{\boldsymbol{\Lambda}}s over iterations, a list of errors over iterations.}
}
\value{
If \code{verbose} is FALSE, the estimated \eqn{\boldsymbol{\Lambda}} is returned.

If \code{verbose} is TRUE, a list with the following elements is returned:
\itemize{
\item \code{coanc_antepops}: The estimated \eqn{\boldsymbol{\Lambda}},
\item \code{coanc_list}: A list of \eqn{\boldsymbol{\Lambda}}'s over iterations,
\item \code{err_list}: A list of \eqn{\|\boldsymbol{\Theta} - \boldsymbol{Q}' \boldsymbol{\Lambda} \boldsymbol{Q}\|_F}'s over iterations.
}
}
\description{
\code{est_coanc()} infers the coancestry among antecedent populations \eqn{\boldsymbol{\Lambda}}.
}
\details{
When the super-admixture model is assumed, \code{est_coanc()} seeks a \eqn{K \times K} matrix
\eqn{\boldsymbol{\Lambda}} that solves this optimization problem:
\deqn{\arg\min\|\boldsymbol{\Theta} - \boldsymbol{Q}' \boldsymbol{\Lambda} \boldsymbol{Q}\|_F}
subject to the constraints:
\enumerate{
\item \eqn{\boldsymbol{\Lambda}} is symmetric
\item \eqn{0 \leq \lambda_{uv} \leq 1} for all \eqn{u,v}
}
When the standard admixture model is assumed, \code{est_coanc()} finds a diagonal \eqn{\boldsymbol{\Lambda}}
that minimizes:
\deqn{\arg\min\|\boldsymbol{\Theta} - \boldsymbol{Q}' \boldsymbol{\Lambda} \boldsymbol{Q}\|_F}
subject to the constraints:
\enumerate{
\item \eqn{0 \leq \lambda_{uu} \leq 1} for all \eqn{u}
\item \eqn{\lambda_{uv} = 0} for all \eqn{u \neq v}
}
}
\examples{
## Estimate Coancestry among antecedent populations of HGDP ----------------------------------------
data("X_hgdp", package = "superadmixture")
data("admix_props_hgdp", package = "superadmixture")
## Estimate kinship coefficients
kinship <- popkin::popkin(t(X_hgdp))
coanc_indiv <- popkin::inbr_diag(kinship)
coanc_indiv <- ifelse(coanc_indiv < 0, 0, coanc_indiv)

## Estimate coancestry among populations
coanc_pops_hgdp <- est_coanc(coanc_indiv, admix_props_hgdp, model = "super")
}
