% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norta.R
\name{norta}
\alias{norta}
\title{Simulate allele frequencies and genotypes using the NORTA method}
\usage{
norta(
  p_anc,
  coanc_antepops,
  admix_proportions,
  p_antepops_only = FALSE,
  geno_only = FALSE,
  parallel = FALSE,
  max_iters = 100,
  tol = 1e-04,
  mc_cores = parallel::detectCores()
)
}
\arguments{
\item{p_anc}{A length-\eqn{m} vector representing allele frequencies at the ancestral population.}

\item{coanc_antepops}{A \eqn{K \times K} matrix representing coancestry among antecedent populations.}

\item{admix_proportions}{A \eqn{K} \eqn{\times} \eqn{n} matrix representing admixture proportions.}

\item{p_antepops_only, geno_only}{Booleans used to control the returned values. If \code{p_antepops_only = T}, only the \eqn{m \times K} matrix of
antecedent allele frequencies \eqn{\boldsymbol{P}} is returned. If \code{geno_only = T}, only the \eqn{m \times n} matrix of genotypes \eqn{\boldsymbol{X}} is returned.
Otherwise, a list containing \eqn{\boldsymbol{P}} and \eqn{\boldsymbol{X}} is returned.}

\item{parallel}{A boolean indicating whether \code{mclapply} is used.}

\item{max_iters}{Maximum number of iterations for Newton-Raphson method in \link{estimate_corrmat}.}

\item{tol}{A scalar for stopping criteria of Newton-Raphson method.}

\item{mc_cores}{An optional integer of number of cores for \code{mclapply}. If not available, \code{mc_cores} will be determined by \code{parallel::detectCores()}.}
}
\value{
\itemize{
\item If \code{p_antepops = T}, an \eqn{m \times K} matrix of allele frequencies of antecedent populations \eqn{\boldsymbol{P}} is returned.
\item If \code{geno_only = T}, an \eqn{m \times n} matrix of genotypes is returned.
\item Otherwise, a named list is returned, containing:
\itemize{
\item \code{p_antepops}: the simulated \eqn{m \times K} matrix of antecedent allele frequencies,
\item \code{X}: the simulated \eqn{m \times n} matrix of genotypes.
}
}
}
\description{
\code{norta()} generates random samples of antecedent allele frequencies \eqn{\boldsymbol{P}} and random samples of genotypes \eqn{\boldsymbol{X}}
according to NORmal-To-Anything method.
}
\details{
Here we consider the problem of simulating a \eqn{K\times 1} dimensional random vector \eqn{\boldsymbol{p}} given a scalar \eqn{a} and a \eqn{K \times K} matrix
\eqn{\boldsymbol{\Lambda}} that satisfies the following moment constraints:
\deqn{\mathbb{E}[p_{u}] = a \quad \forall u \in 1, \ldots, K}
\deqn{\text{Cov}(p_u, p_v) = a(1 - a)\lambda_{uv} \quad \forall (u,v) \in 1, \ldots, K}
Let \eqn{\Phi} denote the univariate standard normal cumulative density function (cdf). Let \eqn{F_u} denote the Balding-Nichols(\eqn{a}, \eqn{\lambda_{uu}}).
Let \eqn{F_u^{-1}} denotes the inverse cdf of \eqn{F_u}. Based on the NORmal-To-Anything method, \eqn{\boldsymbol{p}} can be generated in two steps.
\enumerate{
\item Simulate a length-\eqn{K} random vector \eqn{\boldsymbol{z}} from the standard multivariate Normal distribution \eqn{\Sigma_{\boldsymbol{z}}}.
\item Let \eqn{p_u} be \eqn{p_u = F_u^{-1}(\Phi(z_u))} for \eqn{u = 1, \ldots, K}.
}
The method for identifying  \eqn{\Sigma_{\boldsymbol{z}}} is described in \link{estimate_corrmat}. To simulate a matrix of antecedent populations allele frequencies,
we adopt the strategy described above to each locus and simulate a random vector \eqn{\boldsymbol{p}_i} at each locus given \eqn{a_i} and  \eqn{\boldsymbol{\Lambda}}.
}
\examples{
## Generate a genotype from HGDP -------------------------------------------------------------------
## It takes several hours to run the following codes.
## For a quick implementation of NORTA method, see `norta_approx` function.
\dontrun{
data("fam_hgdp",         package = "superadmixture")
data("p_anc_hgdp",       package = "superadmixture")
data("admix_props_hgdp", package = "superadmixture")
data("coanc_pops_hgdp",  package = "superadmixture")
X_hgdp <- norta(
    p_anc = p_anc_hgdp,
    coanc_antepops = coanc_pops_hgdp,
    admix_proportions = admix_props_hgdp,
    parallel = TRUE,
    geno_only = TRUE)

## Estimate kinship from the simulated genotypes
kinship <- popkin::popkin(X_hgdp)
coanc_indiv <- popkin::inbr_diag(kinship)
coanc_indiv <- ifelse(coanc_indiv < 0, 0, coanc_indiv)

## Visualize kinship
popkin::plot_popkin(coanc_indiv, labs = fam_hgdp$subpop, labs_las = 2)}

}
\seealso{
\link{estimate_corrmat} for details about finding the correlation matrix \eqn{\Sigma_{\boldsymbol{z}}}.
}
