% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/norta.R
\name{norta_approx}
\alias{norta_approx}
\title{An accelerated NORTA implementation for simulating allele frequencies and genotypes}
\usage{
norta_approx(
  p_anc,
  coanc_antepops,
  admix_proportions,
  p_antepops_only = FALSE,
  geno_only = FALSE,
  parallel = FALSE,
  max_iters = 100,
  tol = 1e-04,
  mc_cores = parallel::detectCores()
)
}
\arguments{
\item{p_anc}{A length-\eqn{m} vector representing allele frequencies at the ancestral population.}

\item{coanc_antepops}{A \eqn{K \times K} matrix representing coancestry among antecedent populations.}

\item{admix_proportions}{A \eqn{K} \eqn{\times} \eqn{n} matrix representing admixture proportions.}

\item{p_antepops_only, geno_only}{Booleans used to control the returned values. If \code{p_antepops_only = T}, only the \eqn{m \times K} matrix of
antecedent allele frequencies \eqn{\boldsymbol{P}} is returned. If \code{geno_only = T}, only the \eqn{m \times n} matrix of genotypes \eqn{\boldsymbol{X}} is returned.
Otherwise, a list containing \eqn{\boldsymbol{P}} and \eqn{\boldsymbol{X}} is returned.}

\item{parallel}{A boolean indicating whether \code{mclapply} is used.}

\item{max_iters}{Maximum number of iterations for Newton-Raphson method in \link{estimate_corrmat}.}

\item{tol}{A scalar for stopping criteria of Newton-Raphson method.}

\item{mc_cores}{An optional integer of number of cores for \code{mclapply}. If not available, \code{mc_cores} will be determined by \code{parallel::detectCores()}.}
}
\value{
\itemize{
\item If \code{p_antepops = T}, an \eqn{m \times K} matrix of allele frequencies of antecedent populations \eqn{\boldsymbol{P}} is returned.
\item If \code{geno_only = T}, an \eqn{m \times n} matrix of genotypes is returned.
\item Otherwise, a named list is returned, containing:
\itemize{
\item \code{p_antepops}: the simulated \eqn{m \times K} matrix of antecedent allele frequencies,
\item \code{X}: the simulated \eqn{m \times n} matrix of genotypes.
}
}
}
\description{
\code{norta()} generates random samples of antecedent allele frequencies \eqn{\boldsymbol{P}} and random samples of genotypes \eqn{\boldsymbol{X}}
according to NORmal-To-Anything method. Instead of estimating \eqn{\boldsymbol{\Sigma}_{\boldsymbol{z}}} for each locus, this method only estimates
\eqn{\boldsymbol{\Sigma}_{\boldsymbol{z}}} for \eqn{a_i = 0.01, 0.02, \ldots, 0.99}. See \link{norta} for details about NORTA simulation.
}
\examples{
## Generate a genotype from HGDP -------------------------------------------------------------------
## It takes 230.851 sec to finish the following codes on a 2.3 GHz 18-Core Intel Xeon W iMac Pro.
\dontrun{
data("fam_hgdp",         package = "superadmixture")
data("p_anc_hgdp",       package = "superadmixture")
data("admix_props_hgdp", package = "superadmixture")
data("coanc_pops_hgdp",  package = "superadmixture")
X_hgdp <- norta_approx(
      p_anc = p_anc_hgdp,
      coanc_antepops = coanc_pops_hgdp,
      admix_proportions = admix_props_hgdp,
      parallel = TRUE,
      geno_only = TRUE)

## Estimate kinship from the simulated genotypes
kinship <- popkin::popkin(X_hgdp)
coanc_indiv <- popkin::inbr_diag(kinship)
coanc_indiv <- ifelse(coanc_indiv < 0, 0, coanc_indiv)

## Visualize kinship
popkin::plot_popkin(coanc_indiv, labs = fam_hgdp$subpop, labs_las = 2)}

}
\seealso{
\link{norta} for details about finding the correlation matrix \eqn{\Sigma_{\boldsymbol{z}}}.
}
